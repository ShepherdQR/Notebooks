%%============
%%  ** Author: Shepherd Qirong
%%  ** Date: 2021-06-12 18:33:02
%%  ** Github: https://github.com/ShepherdQR
%%  ** LastEditors: Shepherd Qirong
%%  ** LastEditTime: 2021-12-01 23:23:39
%%  ** Copyright (c) 2019--20xx Shepherd Qirong. All rights reserved.
%%============
\documentclass[UTF8]{article}
\usepackage{ctex}
\usepackage{amsmath,amsthm,amsfonts,amssymb,bm,mathrsfs,upgreek} 
\usepackage[paper=a4paper,top=3.5cm,bottom=2.5cm,
left=2.7cm,right=2.7cm,
headheight=1.0cm,footskip=0.7cm]{geometry}
\usepackage{color,xcolor}
\RequirePackage{setspace}
\setstretch{1.523}

\usepackage{listings}
\lstset{breaklines}%这条命令可以让LaTeX自动将长的代码行换行排版
\lstset{extendedchars=false}%这一条命令可以解决代码跨页时，章节标题

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
backgroundcolor=\color{white},   % choose the background color
basicstyle=\footnotesize\ttfamily,        % size of fonts used for the code
columns=fullflexible,
breaklines=true,                 % automatic line breaking only at whitespace
captionpos=b,                    % sets the caption-position to bottom
tabsize=4,
commentstyle=\color{mygreen},    % comment style
escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
keywordstyle=\color{blue},       % keyword style
stringstyle=\color{mymauve}\ttfamily,     % string literal style
frame=single,
rulesepcolor=\color{red!20!green!20!blue!20},
% identifierstyle=\color{red},
language=c++,
}

\begin{document}
\title{CPP Study Note}
 
\section{代码规范}

修改注释，例如
---[[修改的代码]]-----






\section{Basic Grammer}

\subsection{Books}

Bjarne Stroustrup推荐要掌握的的5种语言：
C++、Java、Python、Ruby和JavaScript


c++ primer v5, the author is the creator of the first c++ compiler.

the c++ programming language v4, the author is the creator of the c++.

the c++ standard library: a tutorial and reference.



\subsection{Reference}
The reference is ofen used as parameters of a function. 
rreference is a const pointer

\begin{lstlisting}
    // const T& or const T cannot be passed to T&
    %* \dots *)
    int var(1);
    int &ref = var; //ref is always the second name of var.
    %*
        \dots
    *)
    int& func(const double& iVal,...){...}
    func() = 3; // We can use the function just as a variable
\end{lstlisting}

 
\subsection{Const}
\begin{lstlisting}
    // const T* can be transformed to T* using (T*)
    %* \dots *)
    int var(1);
    const int* pCanNotModifyVar = &var; //const T* p CANNOT modify the variable it points to.

    const int& num = 10;//ok
    int& num = 10;//wrong
\end{lstlisting}
const object function can only be called by const object.\\

\begin{lstlisting}
    void testFuncAdd20210718_2()
{
    const int a = 10;
	int* pConstModifier = (int*)&a;// compiler finds and allocates memory
	const int  *q = &a;
	{
		*pConstModifier = 20;
	}
	std::cout <<a <<std::endl;//10
	std::cout <<*pConstModifier <<std::endl;//20
	std::cout << (&a == pConstModifier ) <<std::endl;//1
	std::cout << (q == pConstModifier ) <<std::endl;//1
}
\end{lstlisting}

\subsection{Memory}
%%\paragraph{Memory} \quad\\
Dynamic
\begin{lstlisting}
    T* p = new T;
    if(p){
        delete p;
        p = nullptr;
    }
    int arraySize(6);
    T* p = new T[arraySize];
    if(p){
        delete[] p;
        p = nullptr;
    }
\end{lstlisting}


\subsection{IO}

dec,hex, oct

\subsection{RTTI与异常处理}
RTTI，运行时类型信息，在类层次结构中漫游，可向上、向下、平行转换，可实现反射、高级调试等功能。

异常处理：安全的longjmp机制。
\begin{lstlisting}
    void function(void) throw(something){//...}
\end{lstlisting}
构造函数中抛出异常会产生不完整的类，永远不会调析构。解决方法：做一个有T*数据成员的模板类A，我们创建的类B中的int* pVal要在B的构造中new，现在改为存A<int>pVal，在B的构造中new，这样new委托给了类A，在我们的类B的构造中throw也不会导致内存泄露。


\section{Function}
函数定义中可以为最右边连续若干参数有省却值,可以用于扩充函数参数时减少对原有代码的修改。
\paragraph{Inline} \quad\\
We use Inline to tell Compiler to do copy-paste. The function is short and called many times.调用时间少了，可执行文件体积增大

完成形参的构造（如调用类的拷贝构造等）之后，再进入函数体内。
\begin{lstlisting}


    
\end{lstlisting}
\paragraph{Oveload} \quad\\
重载。Functions with the same name but the variables are different.We donot care the returned type.




\section{Object}

1) Do not set data member public.
2) Try the best to use reference as the io of functions.
3) Use const as most as possible.
4) use initial list in constructor.
结构化程序设计没有封装和隐藏的概念，导致数据结构与函数之间相互的关系、函数之间的调用关系不明确。
把数据结构和对其进行的操作方法放在一起。

stack object, also called auto object. 
static object will be created once, it will not be delete until the program ends.
global object, outside every {}, its scale is the whole program.

类的实现也可以直接在.h中。
\subsection{Basic}
给出了构造函数，编译器不默认提供无参构造函数。
复制构造函数，只有1个
\begin{lstlisting}
    C（const C& iC);
    C();//临时对象，下一个语句就析构了。
\end{lstlisting}
返回值是类A的实例时，函数返回时调用A的复制构造函数

声明时可给出变量的初始值，后面可在构造函数中重新赋值。


解决菱形继承，在第一级继承时使用virtual:public,这样后面每次实例化时要调用虚基类的构造函数。
\begin{lstlisting}
    //类型转换构造函数
    C（int iIn)
    C c1 = 12, c2;
    c2 = 9;//error
    c2 = C(9); // ok
\end{lstlisting}



\begin{lstlisting}
    //When we new a class: 
    C* pC = new C(1,2);
    // The compiler transformed into 3 steps:

    void* mem = operator new(sizeof C);//Inside it calls malloc(n);
    pC = static_cast<C*>(mem);
    pC->C::C(1,2);

    // When delete a class:
    delete pC;
    // It turns into:
    C::`C(pC);//Clear the data.
    operator delete(pC);//Insid it calls free(pC); //free the memory.
\end{lstlisting}



参数对象消亡时调用析构函数；函数返回时是生成临时对象返回，在临时对象调用的那条语句之后，临时对象消亡，调用析构。

When we do something in constructor, we need to make sure the function works well in copy constructor.

在构造函数的初始化列表中对类的成员类进行初始化,，顺序是类中成员声明顺序。

\subsection{Decoration}
没有使用成员变量的方法，可以通过空的类指针调用，相当于翻译后传了一个空的this指针。static方法也可以空类指针调用，static方法参数中没有this指针 \\
static和global在main结束后按入栈的顺序析构。\\
sizeof doesn't contain static variables.\\
friend function, a class must declare WhichClass::WhichFunction is its friend, so that the specific function can access its private members. Also the same as friend class.\\
friend relationship cannot be passed, or be inherited.\\
每个对象的空间中都有this指针。（x）\\

\begin{lstlisting}
  提示编译器不生成默认复制构造函数：A(CONST A&)=delete;
  提示编译器提供默认构造函数 A()=default;
  默认情况一旦写了构造函数，编译器就不生成无参的默认构造函数了。
  委托构造函数 A():A(0,0,0){}
\end{lstlisting}

const function cannot modidfy class members. 
final, means this function or class cannot be inherited.
override, compiler will check the function, and if it is not override a function in its base, it tells you the error.
Outsied, a const class can only use const functions.


\section{Templatte}
sortable, comparable, assignable.

Data type int is a comparable modle.

Iterators connects the containers with algorithms.

\section{STL}
\subsection{Contianer}
\begin{lstlisting}

Sequence and reversible:
list 

Sequence and random access:
vector, deque

Associative and reversible:
    set, multiset, map, multimap  

    array, , forward_list,  

unordered_set, unordered_multiset, unordered_map, unordered_multimap  


\end{lstlisting}

\section{UML}
united modeling language. 






\section{Design Pattern}
\subsection{Principles}
Open for extension, closed for modification. 对扩展开放，对修改封闭。类的改动通过增加而不是修改代码实现。
Single Responsibility. 类对外提供一种功能。模块只能有一种被修改的理由。
Dependence inversion. 依赖接口。业务层与实现层都向协议层靠拢。
interface segegation. 一个接口提供一种功能。
Liskov substitution. 抽象类出现的地方都可以用其实现类替换。
composite or aggregate reuse. 优先使用组合，因为继承时父类的修改会影响子类，对象组合会降低依赖关系。
law of demeter一个对象应对其他对象尽量少的了解。



\section{Others}




\begin{lstlisting}
   http://api.open-notify.org/astros.json

   https://openweathermap.org/current

\end{lstlisting}


建议把xy push到局部vector中，把局部vector push到vec中

Notepad++里Run可以设置用.bat来编译运行，bat里面要先cd到其目录

penetration test, using attack tools.

进程因为创建而就绪，因为调度而运行，因为IO事件而阻塞，IO事件完毕或时间片用完回到就绪状态，运行完成后消亡。

c++看gcc-cp目录

它是个编译器，也可以画图写别的pythonjava之类的

我都没有研究过，我需要找点资料好好学习一下，个人觉着c用起来更像是地址的别名，fortran的更像是地址的别名的别名，两个的比较应该找一些开源的转换库看看，

\begin{lstlisting}
    using namespace std;在局部使用挺好的
   using FP = void (*) (int, const std::string&); //Replace using typedef
\end{lstlisting}


伸缩型数组，在c中比存指针成员的好处是1）不占1个地址的存储空间，2）最适合制作动态buffer，因为可以直接就把buffer的结构体和缓冲区一起分配。
\begin{lstlisting}
   struct MyStruct
   {
       int			i；
       float		j；
       double		arr[0];		//伸缩型数组成员
       //double	arr[];		//这样声明也可以
   }；
   pf = malloc(sizeof(MyStruct) + N*sizeof(double));/*只分配一块内存*/
\end{lstlisting}
c\#生态还是局限


假如一种语言不允许运行期动态分配内存的话，确实只要有stack就够了，内存的数据区只划分成两大块，一块用于独立于过程的数据（编译、连接时已知大小），剩下的全部做为一个stack。C、C++这样的允许动态分配内存的语言，当然还是要有一个heap的，这样内存就划分成三个区域了。在引入线程概念之前，确实如你所想的，除了运行时动态确定大小的数据必须放在heap里面，其他都可以放在stack里，我们可以把stack设置的足够大。然而，后来线程出现了。每个线程有自己独立的stack，一个程序可以创建成百上千个线程，那么stack的大小也就只能是一个很小的值，内存才不会被用光。在windows系统里，每个线程的stack默认只有1MB，LINUX默认8MB，这样，stack就成了紧缺资源，必须非常有节制地使用，体量比较大的数据都要由程序员手工分配到heap里去并手工管理其生命期。

java 半编译半解释

反码：符号位不变，其余位翻转。
正整数的补码：是原码；
负整数的补码：是反码+1；
注意运算可能溢出。

\begin{lstlisting}
   a = 3*5,a*4;//60
   typedef int MyINT;
   using MyINT = int;

   decltype(i) j = 2;//the type of j is the same as i.
initializer_list


 \end{lstlisting}

 每一个练习封装成一个函数收集在一个.hpp里面，在一个main里面调用相应的练习函数

 我认为核心还是数据，设计类的方法要围绕着数据来，公开出去的方法要维护好隐藏起来的成员变量

 量子加密RSA

 原来stl的模板采用的那叫静态多态，编译期间翻译，所以模板的声明实现分离在头文件里实例一份就行了
\end{document}