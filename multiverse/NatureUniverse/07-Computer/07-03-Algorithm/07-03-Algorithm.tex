%%============
%%  ** Author: Shepherd Qirong
%%  ** Date: 2022-06-05 00:00:41
%%  ** Github: https://github.com/ShepherdQR
%%  ** LastEditors: Shepherd Qirong
%%  ** LastEditTime: 2022-06-05 20:28:59
%%  ** Copyright (c) 2019--20xx Shepherd Qirong. All rights reserved.
%%============

\documentclass[UTF8]{../computerUniverse}
\begin{document}
\title{07-03-Algorithm}
\date{Created on 20220605.\\   Last modified on \today.}
\maketitle
\tableofcontents








\chapter{计算模型合集}
各种高效实用的计算模型

\chapter{数据结构}


\subsubsection{数组}
 a[i] = a+i*len ;//i from 0;
 a[i][j]  按行存：a+ (i*len +j )*len ;
 a[i][j]  按列存：a+ (j*len +i )*len ;

 5*5的二维数组a，各元素2字节，a[2][3]行有限存，地址？
 2*5+3 = 13, 13*2 = 26, a+26;
\subsubsection{线性表}

\subsubsection{树与二叉树}

二叉树遍历：前序、后续、中序。
反向构造二叉树：利用 前+中，或后+中遍历结果，推出树的结构。只利用前+后不行。

树转二叉树：第一个孩子在左，兄弟都是右。

查找二叉树：左<根<右


最优二叉树、哈夫曼树：带权路径长度最小。 
1,2,8,4构造哈夫曼树：
step1: 1,2-->3; 3,8,4;
step2: 3,4-->7;7,8
so:        15
      7       8
   3    4
1    2
权值： 1*3+2*3 +4*2+8*1 = 25

线索二叉树：前序、后续、中序，列举各元素后，叶子LR指针指向前后元素。

平衡二叉树：
任意结点左子树与右子树深度差不大于1。
平衡度=左子树深度-右子树深度。


\subsubsection{图}
有向图，无向图。
完全图。

存储：
邻接矩阵。n个点，n*n。i到j有邻接边，Rij=1，否则为0。
邻接表，$V1-->[2,6,--]-->[4,1,--]-->[6,50,^]//$V1到2号结点距离6，到4号结点距离1，到6号结点距离50

【遍历】深度优先，广度优先。

【拓扑排序，AOV网络】有向边表示活动之间开始的先后关系。

【图的最小生成树，普里姆算法】留下的权值最小。
树没有环路，n个节点的树边最多n-1个。
染色红，逐个收集最短的一个元素进来。注意过程中不能形成环。

【图的最小生成树，克鲁斯卡尔算法】从最短的边开始选边。



\chapter{算法合集}
一般难解问题的高效实用算法


\subsection{计算几何}

\subsection{分布式算法}
\subsection{并行算法}
\subsection{随机算法}




\subsection{算法}
又穷，确定，有效。

【复杂度】时间，空间

时间复杂度：$1,log_2n,n,nlog_2n,n^2,n^3,...,2^n$

\subsubsection{查找}

【顺序查找】
平均查找长度：$\frac{n+1}{2}$
time,O(N)

【二分查找】
有序排列。
比较次数最多$\left\lfloor log_2n\right\rfloor +1$
time,O($log_2n$)

【散列表】
例如，存储空间10，p=5，散列函数$h=key\%p$,
存储3,8,12,17,9：线性探测： 3,4，2，5,6
冲突解决：线性探测，伪随机数。

\subsubsection{排序}

稳定、不稳定。【 一样的数，保持原顺序，叫稳定】

【插入式：直接插入】
新的一个与已经排好的比，插入到位置

【插入式：希尔】
数据少时插入排序效率可以。

例如10个元素，先
d=n/2=5,隔5个一组，插入排序；
d = d/2  =2,取奇数是3；隔3个一组，插入；
d = d/2 = 1，全体插入排序。


【选择式：直接选择】
每次选剩余最小的。

【选择式：堆排序】完全二叉树。。
小顶堆：$k_i<=k_{2i}, k_i<=k_{2i+1}$
大顶堆：$k_i>=k_{2i}, k_i>=k_{2i+1}$ 所有孩子都更小

从小到大排列：建小顶堆--》取顶--》建小顶堆--》。。。。

例如构造大顶堆：
step1，数组顺序构造完全二叉树。
step2，最后一个非叶子节点，与其2个孩子调整为大顶堆；
       倒数第2个非叶子节点，依次调整。如果有子树，要调整后继续调整子树。
       




【交换式：冒泡】

【交换式：快速】



【归并排序】

【基数排序】




\chapter{算法综合案例}
面向应用的大尺度难解问题的工程实用算法


\chapter{工程算法集成和相应软件体系结构}

\chapter{工程算法分析和评价体系}

\end{document}
