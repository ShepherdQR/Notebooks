%%============
%%  ** Author: Shepherd Qirong
%%  ** Date: 2022-06-05 00:00:41
%%  ** Github: https://github.com/ShepherdQR
%%  ** LastEditors: Shepherd Qirong
%%  ** LastEditTime: 2023-04-09 22:20:50
%%  ** Copyright (c) 2019--20xx Shepherd Qirong. All rights reserved.
%%============

\documentclass[UTF8]{../computerUniverse}
\begin{document}
\title{07-03-Algorithm}
\date{Created on 20220605.\\   Last modified on \today.}
\maketitle
\tableofcontents








\chapter{计算模型合集}
各种高效实用的计算模型










\chapter{数据结构}

\section{AAA}


\subsection{数组}
 a[i] = a+i*len ;//i from 0;
 a[i][j]  按行存：a+ (i*len +j )*len ;
 a[i][j]  按列存：a+ (j*len +i )*len ;

 5*5的二维数组a，各元素2字节，a[2][3]行有限存，地址？
 2*5+3 = 13, 13*2 = 26, a+26;


\subsection{线性表、链表}



\subsection{栈}


\subsection{队列}

\subsubsection{优先队列}


\subsection{哈希表}

\subsubsection{哈希函数}
哈希函数：y=H(x), 输出长度不变；相同输入每次得到相同输出；输入差距小也会导致输出差距大，输入差距大也可能导致输出相同。x求y容易，y求x困难。

MD5, message digest algorithm 5
SHA-1, SHA-2, source hash algorithm.
MD5, SHA-1 存在安全隐患。




\subsection{堆}
上浮和下沉，用于实现priority queues


\subsection{树}


\subsubsection{二叉树}

二叉树遍历：前序、后续、中序。
反向构造二叉树：利用 前+中，或后+中遍历结果，推出树的结构。只利用前+后不行。

树转二叉树：第一个孩子在左，兄弟都是右。


查找二叉树：左<根<右
1）左子树的值<根的值<右子树的值；
2）一直向左达到最小值，一直向右达到最大值；
3）增加节点：从根开始，向末端方向，插入值更小就左转，否则右转，到达末端增加一个叶子节点；
4）删除节点A：A的左子树的最大节点替代删除的A的位置；
5）扩展：平衡二叉查找树；B树（m个节点的形状平衡的）。



最优二叉树、哈夫曼树：带权路径长度最小。 
1,2,8,4构造哈夫曼树：
step1: 1,2-->3; 3,8,4;
step2: 3,4-->7;7,8
so:        15
      7       8
   3    4
1    2
权值： 1*3+2*3 +4*2+8*1 = 25

线索二叉树：前序、后续、中序，列举各元素后，叶子LR指针指向前后元素。

平衡二叉树：
任意结点左子树与右子树深度差不大于1。
平衡度=左子树深度-右子树深度。



\subsection{图}
有向图，无向图。
完全图。

存储：
邻接矩阵。n个点，n*n。i到j有邻接边，Rij=1，否则为0。
邻接表，$V1-->[2,6,--]-->[4,1,--]-->[6,50,^]//$V1到2号结点距离6，到4号结点距离1，到6号结点距离50

【遍历】深度优先，广度优先。

【拓扑排序，AOV网络】有向边表示活动之间开始的先后关系。

【图的最小生成树，普里姆算法】留下的权值最小。
树没有环路，n个节点的树边最多n-1个。
染色红，逐个收集最短的一个元素进来。注意过程中不能形成环。

【图的最小生成树，克鲁斯卡尔算法】从最短的边开始选边。




\chapter{随机算法}


\section{随机数生成}

\subsection{Mersenne Twister}
梅森旋转（Mersenne Twister, MT）算法，常用是伪随机数生成算法。算法描述如算法\ref{algo:2ch001MersenneTwister}所示。

      \begin{algorithm}[ht]
        \caption{Mersenne Twister}\label{algo:2ch001MersenneTwister}
        \SetAlgoLined
        \KwIn{the index is noted as $x_{in}$, the seed number is noted as ${\rm seed}$}
        \KwOut{random number $x_{out}$}
        Initialization:$[w, n, m, r], a, f$,$(u,d),(s,b),(t,c),l$, $MT_0 \leftarrow {\rm seed}$\;
        \For{$i \leftarrow 1$ \KwTo $n-1$}{
          $MT_{i} \leftarrow f \cdot \left\{ MT_{i-1} \oplus [MT_{i-1} >> (w-2)] +i \right\}$
        }
        \For{$i \leftarrow 0$ \KwTo $n-2$}{
          $M_c \leftarrow$ the commposition of the higest $w-r$ bits of $MT_i$ and the lowest $r$ bits of $MT_{i+1}$\;
          $M_c \leftarrow M_c >> 1$\;
          \If{the lowest bit of $M_c$ is $1$}{
            $M_c \leftarrow M_c \oplus a$
          }
          $MT_i \leftarrow MT_{i+m} \oplus M _c$
        }
        $x \leftarrow MT_{x_{in}}$\;
        $x_{out} \leftarrow x \oplus [ (x >> u) \ \& \  d]$\;
        $x_{out} \leftarrow x \oplus [ (x << s) \ \& \ b]$\;
        $x_{out} \leftarrow x \oplus [ (x << t) \ \& \  c]$\;
        $x_{out} \leftarrow x \oplus  (x >> l) $\;
        \KwRet $x_{out}$\;
      \end{algorithm}






\chapter{算法合集}
一般难解问题的高效实用算法

有穷，确定，有效。

【复杂度】时间，空间

时间复杂度：$1,log_2n,n,nlog_2n,n^2,n^3,...,2^n$




\section{计算几何}

\section{分布式算法}
\section{并行算法}





\section{查找}


\subsection{顺序查找、线性查找}
平均查找长度：$\frac{n+1}{2}$
time,O(N)


\subsection{二分查找}
有序排列。对于有序数组，每次甩掉一半可能区间。
比较次数最多$\left\lfloor log_2n\right\rfloor +1$
time,$O(log_2n)$


\subsection{散列表查找}
例如，存储空间10，p=5，散列函数$h=key\%p$,
存储3,8,12,17,9：线性探测： 3,4，2，5,6
冲突解决：线性探测，伪随机数。



\section{排序}

稳定、不稳定。【 一样的数，保持原顺序，叫稳定】



\subsection{插入式：直接插入}
插入：$O(n^2)$，认为第1个已排序，剩余的依次插入到合适位置。

新的一个与已经排好的比，插入到位置


\subsection{插入式：希尔}
数据少时插入排序效率可以。

例如10个元素，先
d=n/2=5,隔5个一组，插入排序；
d = d/2  =2,取奇数是3；隔3个一组，插入；
d = d/2 = 1，全体插入排序。


\subsection{选择式：直接选择}
选择：$O(n^2)$，每次从剩余数组中挑最小的。

每次选剩余最小的。


\subsection{选择式：堆排序}
完全二叉树。
堆：$O(nlogn)$，构造堆，不断取根-维护堆结构。
小顶堆：$k_i<=k_{2i}, k_i<=k_{2i+1}$
大顶堆：$k_i>=k_{2i}, k_i>=k_{2i+1}$ 所有孩子都更小

从小到大排列：建小顶堆--》取顶--》建小顶堆--》。。。。

例如构造大顶堆：
step1，数组顺序构造完全二叉树。
step2，最后一个非叶子节点，与其2个孩子调整为大顶堆；
       倒数第2个非叶子节点，依次调整。如果有子树，要调整后继续调整子树。
       

\subsection{交换式：冒泡}
冒泡：$O(n^2)$，认为数组是从地板到天花板，每轮都从地板开始冒泡，每轮导致天花板降低；天地相接或某一轮的所有冒泡没有产生相邻的交换，认为排好序。


\subsection{交换式：快速}    
快速：$O(nlogn)$，递归的分治法
每次操作F是把当前处理的区间划分为3个部分：[小于基准的数区间]基准数[大于基准的数区间]。对左右2个区间递归执行操作F。


\subsection{归并排序}

归并：$O(nlogn)$，递归的分治法
1）自顶而下：不断细分，然后归并。归并要保证两帧有序。


\subsection{基数排序}




\section{图的搜索}

\subsection{广度优先}
广度优先：FIFO（先入先出），用队列。


\subsection{深度优先}
深度优先：LIFO（后入先出），用栈。


\subsection{Bellman-Ford}
Bellman-Ford：无向图中最短路径问题。
从A节点到B节点，节点间度量为正。设置初始权重起点为0，其余点无穷大。广度优先，更新各个节点的权重值，有更小的时更新权重值。


\subsection{Dijkstra}
Dijkstra：无向图中最短路径问题。
从A节点到B节点，节点间度量为正。设置初始权重起点为0，其余点无穷大。计算与A连接是边中最短的节点K1，然后计算与K1连接是边中最短的节点K2，持续下去直到B。


\subsection{A-star}
A-star：Dijkstra并没有一个指向性保证一次性走到终点。增加一种引导，如当前点与终点的估计距离，引导每次对最短节点K1的选择。这样的算法称为“启发式算法”。



\section{安全算法}

A向B数据传输4个问题：
1）窃听：C听到了；【加密】
2）假冒：A或B是假的；【消息认证、数字签名】
3）篡改：B收到的是C修改后的A发送的消息；【消息认证、数字签名】
4）事后否认：A事后不承认消息了。【数字签名】
数字签名中，为了确认公开秘钥的制作者，使用“数字证书”技术。



\subsection{利用秘钥加密}

\subsubsection{共享秘钥加密}
【共享秘钥加密。对称加密】DES，AES，凯撒密码，动态口令。
1）加密和解密用相同的秘钥。秘钥从A发送到B的过程中，也可能被窃听。秘钥分配问题。
2）秘钥分配问题的解决方案：密钥交换协议，公开秘钥加密。


\subsubsection{公开秘钥加密}
RSA算法、椭圆曲线加密算法。
1）B生成公钥P和私钥S，B把P发给A，A用P加密后把密文发给B，B用S解密。
2）假设n个人互相传输，需要n(n-1)/2对秘钥。改进是想B对所有的人都保持1个P和1个S。
3）安全问题：【中间人攻击】在B把P发给A时，C截获P，把Q发给A，A用Q加密后的密文再次被C截获，C解密后修改，再用P加密传给B。问题是由于A不知道收到的秘钥是否来自B。用数字证书解决。
4）加密解密时间长，不适合持续发送小数据的情形。用混合加密解决。
5)RSA算法中利用Miller-Rabin质数测试。


\subsubsection{混合加密}
SSL/TLS协议。
数据用共享秘钥加密，发送的秘钥信息用公开密钥加密。


\subsubsection{Diffie-Hellman密钥交换}
1）构造秘钥合成算法F = [P, S],具有特点：1）可合成不可分解；合成后可继续合成；合成结果与合成顺序无关。
2）A和B公开秘钥P，A准备SA，A传输[P, SA]给B；B准备SB，A传输[P, SB]给A；A和B各自组合出[P, SA, SB]用于加密和解密。窃听者无法组合出。
2）A和B公开大质数P和另外一个数G；A选一个数x，A发送$(G^x)modP$给B；B选一个数y，B发送$(G^y)modP$给A；A和B都用秘钥$(G^{xy})modP$。根据质数P、生成元G、$(G^x)modP$，求x的问题，称为离散对数问题，该问题至今没找到解法。



\subsection{消息认证码}
认证、检测篡改
A把秘钥P安全发给B；A用密文和秘钥P生成消息认证码如ab12，称为MAC(Message authentication code)；B收到密文和MAC后，用密文和秘钥生成一份MAC和A发来的比较是否一样。
MAC算法：HMAC, OMAC, CMAC
缺点：无法保证密文是A生成的还是B生成的。问题原因是两方都有相同的秘钥，不能确定MAC是谁生成的。解决方案：数字签名。


\subsection{数字签名}
希望：A的签名发送给B，B可以验证签名，B不能生成签名。
1）公开秘钥加密是P加密S解密；数字签名是S加密P解密。
2）A准备发签名，A准备好P和S；A用S加密得到签名，公开P。能够用A发布的P解密的，一定是A的S加密生成的。
3）求消息的哈希值X，对X加密得到签名。
4）问题：需要知道公钥P的制作者，防止C用自己的公钥冒充A的。解决方法：数字证书。


\subsection{数字证书}
A和B之间的事，找一个双方承认的中间人。
A把要公开的秘钥PA和自己的个人信息提交给认证中心（CA,Certification Authority）；CA确认后利用CA的私钥将PA和个人信息生成签名作为A的证书。B收到证书后，利用CA的公钥PC检测证书。
1）问题：检测证书的公钥PC是来自CA的吗？CA的PC是以数字证书的形式交付的，有更高级别的CA署名。
2）根认证中心，其正当性由自身证明，如大型企业。
3）网站的证书称为“服务器证书”，与域名信息对应。可确认域名和存储网站本身的服务器由同一个组织管理。
4）PKI，public key infrastructure, 公钥基础设施。



\section{聚类算法}

\subsection{k-means}
随机选择凝聚中心，得到n个集合；利用集合重心作为新的凝聚中心，计算新一轮的簇。重复下去得到最终的n个集合。

\subsection{层次聚类}
初始时每个对象为1类；每次将最近的2类合并为1类，持续下去。



\section{其他算法}

\subsection{欧几里得算法（又称辗转相除法）}
1）A = k1*gcd(A, B), B = k2*gcd(A, B),A和B看做相同刻度的不同数量的尺子，不断把长的重新赋值为长的减去短的，直到最后剩下长度之比为1:2，得到了刻度。
2）令L0 > R0;
L1 = R0,R1 = L0 mod R0；
一直到Lk, Rk,Rk = 0,Lk = gcd(L0， R0)


\subsection{质数判断}
1）根据定义枚举：计算A的平方根n，i:[2,n]，r[i] = A mod i;r[i]中有0表示有公因数，即不是质数。
2）费马测试：对于质数p，任意小于p的数c，有$(c^p)mod(p) = c$。测试A，随机找几个小于A的数，判断通过费马测试，大概率认为是质数。
3）存在满足费马测试的合数，称为Carmichael Numbers，绝对伪质数，如561.
4）AKS算法，多项式时间内进行质数测试。


\subsection{PageRank}
1）利用网页间的链接关系判断网页的价值。
2）A链接指向x个网页，x个网页评分A的权重；A被y个网页指向，A的评分等于来的各个网页的权重之和；为了解决循环链接，引入随机游走，即有a的概率跳到其他的节点，有1-a的概率沿着链接关系走。


\subsection{汉诺塔问题}
递归
1）移动方法F满足：F（n）=F（F（n-1))


\subsection{杨辉三角}


\chapter{算法大全}


\begin{proposition}
  给定3边边长，判断三角形类型:$c = \max(a,b,c), T = c^2 -a^2-b^2$,利用T的符号。
\end{proposition}


\begin{proposition}
  小于A的所有质数:$a = \lfloor \sqrt{A}\rfloor. i\in \{2,3,\cdots, a\}, Answer  =\{i|a\} $.
\end{proposition}


\chapter{算法综合案例}
面向应用的大尺度难解问题的工程实用算法





\chapter{工程算法集成和相应软件体系结构}

\chapter{工程算法分析和评价体系}

\end{document}
