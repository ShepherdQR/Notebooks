%%============
%%  ** Author: Shepherd Qirong
%%  ** Date: 2022-06-05 00:00:41
%%  ** Github: https://github.com/ShepherdQR
%%  ** LastEditors: Shepherd Qirong
%%  ** LastEditTime: 2024-09-15 20:54:11
%%  ** Copyright (c) 2019--20xx Shepherd Qirong. All rights reserved.
%%============

\documentclass[UTF8]{../computerUniverse}

%\SetAlgoSkip{} % 用于移除算法与文字之间的额外间距

\begin{document}
\title{07-03-Algorithm}
\date{Created on 20220605.\\   Last modified on \today.}
\maketitle
\tableofcontents



\chapter{Website}

一道题目从0开始思考

NOI级别

Petrozavodsk Camp


知识框架+刷题。或者边做边学。



\begin{lstlisting}

  1. OI倾向的OJ：

  a) 洛谷：https://www.luogu.com.cn
  
  b) BZOJ：https://www.lydsy.com/JudgeOnline
  
  c) UOJ：http://uoj.ac
  
  d) Libre OJ：https://loj.ac


 CNOI风格，知识点 ==》 题目。对知识和思维的提高帮助有限。
 
 带权带花树板子


 2. 个人比赛平台

a) Codeforces Round：https://codeforces.com

b) Atcoder Round：https://atcoder.jp

c) Topcoder：https://www.topcoder.com

d) Codechef：https://www.codechef.com

e) Random OJ Round，如牛客挑战赛（？）



3. 组队比赛平台

a) Codeforces Gym：https://codeforces.com/gyms

b) Opentrains：http://opentrains.snarknews.info

c) Yandex：https://contest.yandex.ru/?lang=en

d) Vjudge：https://vjudge.net


首先是Codeforces Gym，里面比较成套的题目有Andrew Stankevich Contest系列，就是ITMO教练在Petrozavodsk Camp每年出的题。我只能说，历史上大多数备战总决赛的队伍都会选择板刷，但因为Andrew的题也逐渐失去了时效性，所以我持保留意见。另一个就是World Finals的题基本都有了，建议在备战WF的时候做，榜上也会有很多不同时代的著名队伍，可以纵向、横向比较。还有就是有很多零散的各个地区的区域赛，都是出题人自愿放上来的，建议按前文提到的选题方式进行辨识。同时Gym里还包含一些Petrozavodsk Camp和OpenCup的题，搜索对应关键字就好了


Opentrains在很长一段时间里，国内都只有实力较强的学校在使用，其本质是就是一个放着大量往年Petrozavodsk Camp和OpenCup题目，可供VP的OJ，需要找Snark要账号。这个Snark的CF id是snarknews，可以私戳。我感觉他只会给出线WF学校/队伍账号，很迷。那实际上，我觉得也不需要非要做这个OJ里的题，一个是我之前说的，难度不适合，另一个是缺少题解和有效讨论，虽然我们历史上有很多人和队伍都在做着相关的题解记录和讨论工作，但是因为我们是做别人手里的题，我们的整理过于分散且太不系统了，我稍微列几个：

i. ICPC CAMP Wiki by 叉姐：http://icpc.camp

ii. ICPC CAMP Forum by 叉姐：https://forum.icpc.camp

iii. Claris‘s Blog：https://www.cnblogs.com/clrs97/

所以，不要随便就去做这些题，一来可能旧，二来你可能签完到就懵逼了，也不知道找谁问。

关于Yandex，实际上我也是去年在zimpha学长的安利下才开始认真看contest.yandex上的东西，也是Snark放上去的。我着重提下Cup of Three Quarterfinals，在这里你可以vp历年东欧子赛区的题目，比如Northern Subregional, Moscow Subregional等等，这些题都非常适合练习。

接下来是Vjudge，通过这个壳，你可以拉去各个OJ的题目，而且还能配以相应的榜。通过vjudge，你可以复现区域赛、多校等国内的题目，可以说是备战区域赛的最重要的一个平台。不过，有些OJ可能自己炸了，也可能版本革新后不再支持复现了，就比较可惜，说的就是你们啊bnuoj和zoj。

4. 其他平台

a) Aizu：http://judge.u-aizu.ac.jp/onlinejudge/finder.jsp?course=CGL

b) Sgu：https://codeforces.com/problemsets/acmsguru

c) Project Euler：https://projecteuler.net

太多了，我就不多举了，Aizu的这个，其实我是在DDF的wiki里找到的，当初cls整理几何板子好像就刷了我给的这个网页里的东西。至于sgu，老牌OJ，据说楼教主刷完了整个OJ。至于PE，我认识的所有能用“板刷PE”形容的人都是卡密一样的人物，就算不是卡密，他出的题也是卡密一样的东西，没错说的就是19ecfinal的某个题。

5. 年度活动

a) OpenCup：http://opencup.ru

b) 多校：http://acm.hdu.edu.cn

c) 训练营：国内如字节跳动和wls


关于OpenCup，我记得叉姐给我的比喻特别准确：她说这东西就是俄罗斯人的多校，只不过整年办而已，题目也来源于世界各地到处白嫖。我觉得，比起做opentrains，我更推荐有条件的情况下去要个opencup账号，周日4:00-9:00跟着做，就算做不来也可以进入相应页面补题。比赛后，都有人会在codeforces发讨论帖，有什么问题也可以在上面问，甚至会有人发题解的sketch，请务必把这个讨论帖mark下来，不然真的很难找。反过来说，opentrains上的一些OpenCup，你牛逼一点也是能反向在cf找到讨论帖的。我觉得这个活动最神奇的是，他根本就不是买题，就是个白嫖的存在，东拿一套camp的题，西要一套区域赛，而且大家都很喜欢送题去给OpenCup，比如前几天的gp of tokyo就是白送的。所以我一直觉得Snark真的很牛逼，真的是白嫖大师，不过这样的活动对全世界来说都是有益的。毕竟能提供给全世界的强队，包括退役传奇队伍和选手过招交流的机会，只此一家。


训练营

\end{lstlisting}






\chapter{计算模型合集}
各种高效实用的计算模型







\chapter{思想}

\section{递推}

\subsection{逆推}
执果索因。


\begin{question}
 车从A到B共akm，油耗bL每km，载油容量cL，问需要沿途如何建立储油点，耗油最少到B？

  \paragraph{S1} solution 1

  从B倒推，插入的首个储油点P0，P0到B走1趟，需要存最少cL，距离c/bkm；
  P1，P1到P0走1+2趟，需要存最少c+cL，距离c/(3b)km；



  $\min k, with \ \frac{c}{b}\sum\frac{1}{2i+1} > a, k\in \{ \mathbb{Z} ^+, 0\}$ and 油耗是$a \times (i+1) + b \times(2i+1) \times (a - \sum\frac{1}{2i-1})$

\end{question}

\subsection{正推}

\section{贪心}


\subsection{key thoughts}

\subsubsection{k-optional}




\subsubsection{局部最优是全局最优}

matroid，矩阵胚，$M = [S,I]$,如S是n个m维的行向量，I是S中挑选的所有的那些线性无关的r个m维的行向量。给m维附加上权值维度信息，则贪心即是在I中找到最优的一组行向量，怎么找呢，每次收集最优的1个行向量即可。为什么每次收集最优的1个行向量即可呢？马上证明。假设最优集是T，挑选的是B，证明B=T。假设不相等，可从B中取出一个x，并加入在T中不在B中的一个y，由于T最优，所以$w_x \leqslant w_y$, 但是构造B的时候选择了x而不是y，说明$w_y \leqslant w_x$， 所以$w_y = w_x$，即证。


\begin{question}
  给定a是n位数，删掉s位后，余下的数最小。如178543删掉4位，最小是13
 
   \paragraph{S1} solution 1

   从左向右遍历a各位s遍，每次做的处理：有递减区间A，删除区间A的首；否则删除最后一位。继续下次遍历。

 
 \end{question}





\section{递归}

\section{分治}

\section{DP}

背包问题：\\
a是10kg，60元，单位价值6；\\
b是20kg，100元，单位价值5；\\
c是30kg，120元，单位价值4；\\
背包50kg，求如何放入总价值最大。

部分背包问题，按单位价值从大到小，(a,b,c)=(10,20,20);

0-1背包问题，需要考虑有物体x和无物体x的情况 => 重叠子问题 => 存表、记忆、DP


\section{枚举}

\section{模拟}





\chapter{数据结构}

\section{AAA}


\subsection{数组}
 a[i] = a+i*len ;//i from 0;
 a[i][j]  按行存: a+ (i*len +j )*len ;
 a[i][j]  按列存: a+ (j*len +i )*len ;

 5*5的二维数组a，各元素2字节，a[2][3]行有限存，地址？
 2*5+3 = 13, 13*2 = 26, a+26;



 

\subsection{线性表、链表}



\subsection{栈}


\subsection{队列}

\subsubsection{优先队列}


\subsection{哈希表}

\subsubsection{哈希函数}
哈希函数: y=H(x), 输出长度不变；相同输入每次得到相同输出；输入差距小也会导致输出差距大，输入差距大也可能导致输出相同。x求y容易，y求x困难。

MD5, message digest algorithm 5
SHA-1, SHA-2, source hash algorithm.
MD5, SHA-1 存在安全隐患。




\subsection{堆}
上浮和下沉，用于实现priority queues


\subsection{树}


\subsubsection{二叉树}

二叉树遍历: 前序、后续、中序。
反向构造二叉树: 利用 前+中，或后+中遍历结果，推出树的结构。只利用前+后不行。

树转二叉树: 第一个孩子在左，兄弟都是右。


查找二叉树: 左<根<右
1) 左子树的值<根的值<右子树的值；
2) 一直向左达到最小值，一直向右达到最大值；
3) 增加节点: 从根开始，向末端方向，插入值更小就左转，否则右转，到达末端增加一个叶子节点；
4) 删除节点A: A的左子树的最大节点替代删除的A的位置；
5) 扩展: 平衡二叉查找树；B树（m个节点的形状平衡的) 。



最优二叉树、哈夫曼树: 带权路径长度最小。 
1,2,8,4构造哈夫曼树: 
step1: 1,2-->3; 3,8,4;
step2: 3,4-->7;7,8
so:        15
      7       8
   3    4
1    2
权值:  1*3+2*3 +4*2+8*1 = 25

线索二叉树: 前序、后续、中序，列举各元素后，叶子LR指针指向前后元素。

平衡二叉树: 
任意结点左子树与右子树深度差不大于1。
平衡度=左子树深度-右子树深度。



\subsection{图}
有向图，无向图。
完全图。

存储: 
邻接矩阵。n个点，n*n。i到j有邻接边，Rij=1，否则为0。
邻接表，$V1-->[2,6,--]-->[4,1,--]-->[6,50,^]//$V1到2号结点距离6，到4号结点距离1，到6号结点距离50

【遍历】深度优先，广度优先。

【拓扑排序，AOV网络】有向边表示活动之间开始的先后关系。

【图的最小生成树，普里姆算法】留下的权值最小。
树没有环路，n个节点的树边最多n-1个。
染色红，逐个收集最短的一个元素进来。注意过程中不能形成环。

【图的最小生成树，克鲁斯卡尔算法】从最短的边开始选边。




\chapter{随机算法}


\section{随机数生成}

\subsection{Mersenne Twister}
梅森旋转（Mersenne Twister, MT) 算法，常用是伪随机数生成算法。算法描述如算法\ref{algo:2ch001MersenneTwister}所示。

      \begin{algorithm}[ht]
        \caption{Mersenne Twister}\label{algo:2ch001MersenneTwister}
        \SetAlgoLined
        \KwIn{the index is noted as $x_{in}$, the seed number is noted as ${\rm seed}$}
        \KwOut{random number $x_{out}$}
        Initialization:$[w, n, m, r], a, f$,$(u,d),(s,b),(t,c),l$, $MT_0 \leftarrow {\rm seed}$\;
        \For{$i \leftarrow 1$ \KwTo $n-1$}{
          $MT_{i} \leftarrow f \cdot \left\{ MT_{i-1} \oplus [MT_{i-1} >> (w-2)] +i \right\}$
        }
        \For{$i \leftarrow 0$ \KwTo $n-2$}{
          $M_c \leftarrow$ the commposition of the higest $w-r$ bits of $MT_i$ and the lowest $r$ bits of $MT_{i+1}$\;
          $M_c \leftarrow M_c >> 1$\;
          \If{the lowest bit of $M_c$ is $1$}{
            $M_c \leftarrow M_c \oplus a$
          }
          $MT_i \leftarrow MT_{i+m} \oplus M _c$
        }
        $x \leftarrow MT_{x_{in}}$\;
        $x_{out} \leftarrow x \oplus [ (x >> u) \ \& \  d]$\;
        $x_{out} \leftarrow x \oplus [ (x << s) \ \& \ b]$\;
        $x_{out} \leftarrow x \oplus [ (x << t) \ \& \  c]$\;
        $x_{out} \leftarrow x \oplus  (x >> l) $\;
        \KwRet $x_{out}$\;
      \end{algorithm}






\chapter{算法合集}
一般难解问题的高效实用算法

有穷，确定，有效。

【复杂度】时间，空间

时间复杂度: $1,log_2n,n,nlog_2n,n^2,n^3,...,2^n$




\section{计算几何}

\section{分布式算法}
\section{并行算法}





\section{查找}


\subsection{顺序查找、线性查找}
平均查找长度: $\frac{n+1}{2}$
time,O(N)


\subsection{Binary Search 二分查找}
有序排列。对于有序数组，每次甩掉一半可能区间。
比较次数最多$\left\lfloor log_2n\right\rfloor +1$
time,$O(log_2n)$


算法描述如算法\ref{algo:search_Binary}所示。

      \begin{algorithm}[h]%[ht]
        \caption{search-Binary-1}\label{algo:search_Binary_1}
        \SetAlgoLined
        \KwIn{ordered range set $S = [l,r)$, the search number $t$}
        \KwOut{$out$. if $t \in S$, the index of $t$, index starts with 0.  if $t \notin S , out = -1$}
        Initialization:$out = -1$\;
        \While {$l < r$}{
          $m = \lfloor \frac{r-l}{2} \rfloor $\;
          \If{$t < m$}{
            $r = m$;
          }
          \ElseIf{$t > m$}{
            $l = m + 1$;
          }
          \Else{
            $out = $ index of $m \in S$\;
            return;
          }
        }
        \KwRet $out$\;
      \end{algorithm}

      \begin{algorithm}[h]%[ht]
        \caption{search-Binary-2}\label{algo:search_Binary_2}
        \SetAlgoLined
        \KwIn{ordered range set $S = [l,r]$, the search number $t$}
        \KwOut{$out$. if $t \in S$, the index of $t$, index starts with 0.  if $t \notin S , out = -1$}
        Initialization:$out = -1$\;
        \While {$l \leqslant  r$}{
          $m = \lfloor \frac{r-l}{2} \rfloor $\;
          \If{$t < m$}{
            $r = m - 1$;
          }
          \ElseIf{$t > m$}{
            $l = m + 1$;
          }
          \Else{
            $out = $ index of $m \in S$\;
            return;
          }
        }
        \KwRet $out$\;
      \end{algorithm}



\subsection{散列表查找}
例如，存储空间10，p=5，散列函数$h=key\%p$,
存储3,8,12,17,9: 线性探测:  3,4，2，5,6
冲突解决: 线性探测，伪随机数。



\section{排序}

稳定、不稳定。【 一样的数，保持原顺序，叫稳定】



\subsection{插入式: 直接插入}
插入: $O(n^2)$，认为第1个已排序，剩余的依次插入到合适位置。

新的一个与已经排好的比，插入到位置


\subsection{插入式: 希尔}
数据少时插入排序效率可以。

例如10个元素，先
d=n/2=5,隔5个一组，插入排序；
d = d/2  =2,取奇数是3；隔3个一组，插入；
d = d/2 = 1，全体插入排序。


\subsection{选择式: 直接选择}
选择: $O(n^2)$，每次从剩余数组中挑最小的。

每次选剩余最小的。


\subsection{选择式: 堆排序}
完全二叉树。
堆: $O(nlogn)$，构造堆，不断取根-维护堆结构。
小顶堆: $k_i<=k_{2i}, k_i<=k_{2i+1}$
大顶堆: $k_i>=k_{2i}, k_i>=k_{2i+1}$ 所有孩子都更小

从小到大排列: 建小顶堆--》取顶--》建小顶堆--》。。。。

例如构造大顶堆: 
step1，数组顺序构造完全二叉树。
step2，最后一个非叶子节点，与其2个孩子调整为大顶堆；
       倒数第2个非叶子节点，依次调整。如果有子树，要调整后继续调整子树。
       

\subsection{交换式: 冒泡}
冒泡: $O(n^2)$，认为数组是从地板到天花板，每轮都从地板开始冒泡，每轮导致天花板降低；天地相接或某一轮的所有冒泡没有产生相邻的交换，认为排好序。


\subsection{交换式: 快速}    
快速: $O(nlogn)$，递归的分治法
每次操作F是把当前处理的区间划分为3个部分: [小于基准的数区间]基准数[大于基准的数区间]。对左右2个区间递归执行操作F。


\subsection{归并排序}

归并: $O(nlogn)$，递归的分治法
1) 自顶而下: 不断细分，然后归并。归并要保证两帧有序。


\subsection{基数排序}




\section{图的搜索}

\subsection{广度优先}
广度优先: FIFO（先入先出) ，用队列。


\subsection{深度优先}
深度优先: LIFO（后入先出) ，用栈。


\subsection{Bellman-Ford}
Bellman-Ford: 无向图中最短路径问题。
从A节点到B节点，节点间度量为正。设置初始权重起点为0，其余点无穷大。广度优先，更新各个节点的权重值，有更小的时更新权重值。


\subsection{Dijkstra}
Dijkstra: 无向图中最短路径问题。
从A节点到B节点，节点间度量为正。设置初始权重起点为0，其余点无穷大。计算与A连接是边中最短的节点K1，然后计算与K1连接是边中最短的节点K2，持续下去直到B。


\subsection{A-star}
A-star: Dijkstra并没有一个指向性保证一次性走到终点。增加一种引导，如当前点与终点的估计距离，引导每次对最短节点K1的选择。这样的算法称为“启发式算法”。



\section{安全算法}

A向B数据传输4个问题: 
1) 窃听: C听到了；【加密】
2) 假冒: A或B是假的；【消息认证、数字签名】
3) 篡改: B收到的是C修改后的A发送的消息；【消息认证、数字签名】
4) 事后否认: A事后不承认消息了。【数字签名】
数字签名中，为了确认公开秘钥的制作者，使用“数字证书”技术。



\subsection{利用秘钥加密}

\subsubsection{共享秘钥加密}
【共享秘钥加密。对称加密】DES，AES，凯撒密码，动态口令。
1) 加密和解密用相同的秘钥。秘钥从A发送到B的过程中，也可能被窃听。秘钥分配问题。
2) 秘钥分配问题的解决方案: 密钥交换协议，公开秘钥加密。


\subsubsection{公开秘钥加密}
RSA算法、椭圆曲线加密算法。
1) B生成公钥P和私钥S，B把P发给A，A用P加密后把密文发给B，B用S解密。
2) 假设n个人互相传输，需要n(n-1)/2对秘钥。改进是想B对所有的人都保持1个P和1个S。
3) 安全问题: 【中间人攻击】在B把P发给A时，C截获P，把Q发给A，A用Q加密后的密文再次被C截获，C解密后修改，再用P加密传给B。问题是由于A不知道收到的秘钥是否来自B。用数字证书解决。
4) 加密解密时间长，不适合持续发送小数据的情形。用混合加密解决。
5)RSA算法中利用Miller-Rabin质数测试。


\subsubsection{混合加密}
SSL/TLS协议。
数据用共享秘钥加密，发送的秘钥信息用公开密钥加密。


\subsubsection{Diffie-Hellman密钥交换}
1) 构造秘钥合成算法F = [P, S],具有特点: 1) 可合成不可分解；合成后可继续合成；合成结果与合成顺序无关。
2) A和B公开秘钥P，A准备SA，A传输[P, SA]给B；B准备SB，A传输[P, SB]给A；A和B各自组合出[P, SA, SB]用于加密和解密。窃听者无法组合出。
2) A和B公开大质数P和另外一个数G；A选一个数x，A发送$(G^x)modP$给B；B选一个数y，B发送$(G^y)modP$给A；A和B都用秘钥$(G^{xy})modP$。根据质数P、生成元G、$(G^x)modP$，求x的问题，称为离散对数问题，该问题至今没找到解法。



\subsection{消息认证码}
认证、检测篡改
A把秘钥P安全发给B；A用密文和秘钥P生成消息认证码如ab12，称为MAC(Message authentication code)；B收到密文和MAC后，用密文和秘钥生成一份MAC和A发来的比较是否一样。
MAC算法: HMAC, OMAC, CMAC
缺点: 无法保证密文是A生成的还是B生成的。问题原因是两方都有相同的秘钥，不能确定MAC是谁生成的。解决方案: 数字签名。


\subsection{数字签名}
希望: A的签名发送给B，B可以验证签名，B不能生成签名。
1) 公开秘钥加密是P加密S解密；数字签名是S加密P解密。
2) A准备发签名，A准备好P和S；A用S加密得到签名，公开P。能够用A发布的P解密的，一定是A的S加密生成的。
3) 求消息的哈希值X，对X加密得到签名。
4) 问题: 需要知道公钥P的制作者，防止C用自己的公钥冒充A的。解决方法: 数字证书。


\subsection{数字证书}
A和B之间的事，找一个双方承认的中间人。
A把要公开的秘钥PA和自己的个人信息提交给认证中心（CA,Certification Authority) ；CA确认后利用CA的私钥将PA和个人信息生成签名作为A的证书。B收到证书后，利用CA的公钥PC检测证书。
1) 问题: 检测证书的公钥PC是来自CA的吗？CA的PC是以数字证书的形式交付的，有更高级别的CA署名。
2) 根认证中心，其正当性由自身证明，如大型企业。
3) 网站的证书称为“服务器证书”，与域名信息对应。可确认域名和存储网站本身的服务器由同一个组织管理。
4) PKI，public key infrastructure, 公钥基础设施。



\section{聚类算法}

\subsection{k-means}
随机选择凝聚中心，得到n个集合；利用集合重心作为新的凝聚中心，计算新一轮的簇。重复下去得到最终的n个集合。

\subsection{层次聚类}
初始时每个对象为1类；每次将最近的2类合并为1类，持续下去。



\section{其他算法}

\subsection{欧几里得算法（又称辗转相除法) }
1) A = k1*gcd(A, B), B = k2*gcd(A, B),A和B看做相同刻度的不同数量的尺子，不断把长的重新赋值为长的减去短的，直到最后剩下长度之比为1:2，得到了刻度。
2) 令L0 > R0;
L1 = R0,R1 = L0 mod R0；
一直到Lk, Rk,Rk = 0,Lk = gcd(L0， R0)


\subsection{质数判断}
1) 根据定义枚举: 计算A的平方根n，i:[2,n]，r[i] = A mod i;r[i]中有0表示有公因数，即不是质数。
2) 费马测试: 对于质数p，任意小于p的数c，有$(c^p)mod(p) = c$。测试A，随机找几个小于A的数，判断通过费马测试，大概率认为是质数。
3) 存在满足费马测试的合数，称为Carmichael Numbers，绝对伪质数，如561.
4) AKS算法，多项式时间内进行质数测试。


\subsection{PageRank}
1) 利用网页间的链接关系判断网页的价值。
2) A链接指向x个网页，x个网页评分A的权重；A被y个网页指向，A的评分等于来的各个网页的权重之和；为了解决循环链接，引入随机游走，即有a的概率跳到其他的节点，有1-a的概率沿着链接关系走。


\subsection{汉诺塔问题}
递归
1) 移动方法F满足: F（n) =F（F（n-1))


\subsection{杨辉三角}


\chapter{算法大全}


\section{数组}
\subsection{Remove Element  移除元素}

\begin{lstlisting}
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1:
给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。

\end{lstlisting}

\begin{algorithm}[h]%[ht]
  \caption{Remove Element-1}\label{algo:Remove Element-1}
  \SetAlgoLined
  Brif: array; swap\;
  Initialization:$l = 0, r = size(S)$\;
  Notation 1: after the algorithm, r is the index of the last element that not equal to t\;
  Notation 2: swap(a,a) does nothing \;
  \KwIn{set $S = [l,r), l = S[0]$,  the removed number $t$.}
  \KwOut{$out$. the length of new set.}
  \While {$l \leqslant  r$}{
   
    \If{$S[l] = t$}{
      $swap(S[l] , S[r] )$\;
      $r \leftarrow r -1$;
    }
    \Else{
      $l \leftarrow l +1$;
    }
  }
  $out \leftarrow r+1$\;
  \KwRet $out$\;
\end{algorithm}

\begin{algorithm}[h]%[ht]
  \caption{Remove Element-2}\label{algo:Remove Element-2}
  \SetAlgoLined
  Brif: array; fast slow pointer\;
  Notation 1: not change the order\;
  \KwIn{set $S = [l,r), l = S[0]$,  the removed number $t$.}
  \KwOut{$out$. the length of new set.}
  Initialization:$p_{slow} = -1$\;
  \For {$p_{fast} : [0, size(S))$}{
   
    \If{$S[p_{fast}] \neq t$}{
      $p_{slow} \leftarrow p_{slow} +1$\;
      $ S[p_{slow}] = S[p_{fast}] $\;
    }
  }
  $out \leftarrow p_{slow}+1$\;
  \KwRet $out$\;
\end{algorithm}


\subsection{有序数组的平方}

\begin{lstlisting}
  给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

  示例 1：
  * 输入：nums = [-4,-1,0,3,10]
  * 输出：[0,1,9,16,100]
  * 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

\end{lstlisting}

\begin{algorithm}[h]%[ht]
  \caption{Suqre of ordered sequence-1}\label{algo:Suqre of ordered sequence-1}
  \SetAlgoLined
  Brif: array; two pointers\;
  \KwIn{ordered set $S = [l,r), l = S[0]$.}
  \KwOut{$T$. the squre set.}
  Initialization:$p_{l} = 0,p_{r} = size(S)$, out set T with the same size of S, all elements set to 0,$p_{t} = size(T)$\;
  \For {$i : [0, size(S))$}{
    $S[i] \leftarrow S[i] ^2$
  }
  \While {$p_{l} \leqslant p_{r}$}{
   
    \If{$S[p_{l}] \leqslant S[p_{r}]$}{
      $T[p_{t}] = S[p_{r}]$\;
      $p_{t} \leftarrow p_{t} - 1$\;
      $p_{r} \leftarrow p_{r} - 1$\;
    }
    \Else{
      $T[p_{t}] = S[p_{l}]$\;
      $p_{t} \leftarrow p_{t} - 1$\;
      $p_{l} \leftarrow p_{l} + 1$\;
    }
  }
  \KwRet $T$\;
\end{algorithm}



\subsection{长度最小的子数组}

\begin{lstlisting}

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

* 输入：s = 7, nums = [2,3,1,2,4,3]
* 输出：2
* 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

https://leetcode.cn/problems/spiral-matrix-ii/submissions/518829536/

class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> out(n, vector<int>(n,0));

        int s[2]{0,0};
        int p[2]{0,0};
        int cur[2]{0,0};
        int br = n-1,bb = n-1, bl=0,bt=0;
        int v[2]{1,0};
        bt -=1;

        out[0][0] = 1;
        for(int i=0;i<n*n;++i){
            

            
         

            int index = 1; // 0 ok, -1 error, 1 try

            while(index ==1){

             

                if((v[0]== 1) &&(v[1]== 0) ){ // go right
                   if(p[0]== br){
                       
                         br -=1;
                        v[0]== 0;v[1] = 1;
                   } else{
                    index = 0;
                   }
                }
                else if((v[0]== 0) &&(v[1]== 1) ){ // go bottom
                   if(p[1]== bb){
                        bb -=1;
                        v[0]== -1;v[1] = 0;
                   } else{
                    index = 0;
                   }
                }

                else if((v[0]== -1) &&(v[1]== 0) ){ // go left
                    if(p[0]< bl){
                        index = -1;
                    }
                   else if(p[0]== bl){
                         bl +=1;
                        v[0]== 0;v[1] = -1;
                   } else{
                    index = 0;
                   }
                }
                else if((v[0]== 0) &&(v[1]== -1) ){ // go top
                   if(p[1] == bt){
                       bt +=1;
                        v[0]== 0;v[1] = 1;
                   } else{
                    index = 0;
                   }
                }
            }

            p[0] = p[0]+v[0];
            p[1] = p[1]+v[1];

            out[p[0]][p[1] ] = i+1;
            std::cout <<p[0]<< ", " << i+1 << std::endl;

        }

        return out;

    }
};
\end{lstlisting}


\begin{algorithm}[h]%[ht]
  \caption{Shortest subarray-1}\label{algo:Shortest subarray-1}
  \SetAlgoLined
  Brif: array; two pointers; Sliding window\;
  \KwIn{ordered set $S = [S[0],S[size(S)]), the number t$.}
  \KwOut{the shortest subarray that sum greater than t, stats with index k, length is len.}
  Initialization:$p_{l} = 0,p_{r} = 0, len = size(S) + 1, k = 0,$, the sum of the subarray $sum = 0$\;
  \For {$p_{r} : [0, size(S))$}{
    $sum \leftarrow sum + s[p_{r}]$\;
    \While {$sum \geqslant t$}{
      $sum \leftarrow sum - s[p_{l}]$\;
      $len = \min(len, p_{r} - p_{l} + 1)$\;
      $k \leftarrow p_{l}$\;
      $p_{l} \leftarrow p_{l} + 1$\;
    }
  }
  
  \KwRet $k, len$\;
\end{algorithm}


\subsection{else}

\begin{lstlisting}


\end{lstlisting}

\begin{proposition}
  给定3边边长，判断三角形类型:$c = \max(a,b,c), T = c^2 -a^2-b^2$,利用T的符号。
\end{proposition}


\begin{proposition}
  小于A的所有质数:$a = \lfloor \sqrt{A}\rfloor. i\in \{2,3,\cdots, a\}, Answer  =\{i|a\} $.
\end{proposition}





\chapter{算法综合案例}
面向应用的大尺度难解问题的工程实用算法





\chapter{工程算法集成和相应软件体系结构}

\chapter{工程算法分析和评价体系}

\end{document}
